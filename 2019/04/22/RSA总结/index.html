<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: RSA总结date: 2019-02-24 22:38:33 tags:###RSA总结 ####核心函数 1.分解n， Pollard­rho整数分解，原理：生成两个整数a和b，计算p=gcd(a­b,n)，直到p不为1或者a,b出现循环为止，若p=n，则 p为质数，否则p为n的一个约数。选取一个小的随机数x1，迭代生成xi=xi­1 ^2+k，一般取k=1，若 序列出现循环则退">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/04/22/RSA总结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: RSA总结date: 2019-02-24 22:38:33 tags:###RSA总结 ####核心函数 1.分解n， Pollard­rho整数分解，原理：生成两个整数a和b，计算p=gcd(a­b,n)，直到p不为1或者a,b出现循环为止，若p=n，则 p为质数，否则p为n的一个约数。选取一个小的随机数x1，迭代生成xi=xi­1 ^2+k，一般取k=1，若 序列出现循环则退">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-22T05:27:02.752Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="title: RSA总结date: 2019-02-24 22:38:33 tags:###RSA总结 ####核心函数 1.分解n， Pollard­rho整数分解，原理：生成两个整数a和b，计算p=gcd(a­b,n)，直到p不为1或者a,b出现循环为止，若p=n，则 p为质数，否则p为n的一个约数。选取一个小的随机数x1，迭代生成xi=xi­1 ^2+k，一般取k=1，若 序列出现循环则退">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-RSA总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/22/RSA总结/" class="article-date">
  <time datetime="2019-04-22T05:25:33.880Z" itemprop="datePublished">2019-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: RSA总结<br>date: 2019-02-24 22:38:33</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><p>###RSA总结</p>
<p>####核心函数</p>
<p>1.分解n，</p>
<p>Pollard­rho整数分解，原理：生成两个整数a和b，计算p=gcd(a­b,n)，直到p不为1或者a,b出现循环为止，若p=n，则 p为质数，否则p为n的一个约数。选取一个小的随机数x1，迭代生成xi=xi­1 ^2+k，一般取k=1，若 序列出现循环则退出。计算p=gcd(xi­1 ­ xi,n)，若p=1，返回上一步，直到p&gt;1为止。若p=n，则n为 素数，否则p为n的一个约数并递归分解p和n/p</p>
<p>c++代码</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;stdio.h&gt;

const int Times = 10;
const int N = 5500;

using namespace std;
typedef long long LL;

LL ct, cnt;
LL fac[N], num[N];

LL gcd(LL a, LL b)
{
    return b? gcd(b, a % b) : a;
}

LL multi(LL a, LL b, LL m)
{
    LL ans = 0;
    a %= m;
    while(b)
    {
        if(b &amp; 1)
        {
            ans = (ans + a) % m;
            b--;
        }
        b &gt;&gt;= 1;
        a = (a + a) % m;
    }
    return ans;
}

LL quick_mod(LL a, LL b, LL m)
{
    LL ans = 1;
    a %= m;
    while(b)
    {
        if(b &amp; 1)
        {
            ans = multi(ans, a, m);
            b--;
        }
        b &gt;&gt;= 1;
        a = multi(a, a, m);
    }
    return ans;
}

bool Miller_Rabin(LL n)
{
    if(n == 2) return true;
    if(n &lt; 2 || !(n &amp; 1)) return false;
    LL m = n - 1;
    int k = 0;
    while((m &amp; 1) == 0)
    {
        k++;
        m &gt;&gt;= 1;
    }
    for(int i=0; i&lt;Times; i++)
    {
        LL a = rand() % (n - 1) + 1;
        LL x = quick_mod(a, m, n);
        LL y = 0;
        for(int j=0; j&lt;k; j++)
        {
            y = multi(x, x, n);
            if(y == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return false;
            x = y;
        }
        if(y != 1) return false;
    }
    return true;
}

LL pollard_rho(LL n, LL c)
{
    LL i = 1, k = 2;
    LL x = rand() % (n - 1) + 1;
    LL y = x;
    while(true)
    {
        i++;
        x = (multi(x, x, n) + c) % n;
        LL d = gcd((y - x + n) % n, n);
        if(1 &lt; d &amp;&amp; d &lt; n) return d;
        if(y == x) return n;
        if(i == k)
        {
            y = x;
            k &lt;&lt;= 1;
        }
    }
}

void find(LL n, int c)
{
    if(n == 1) return;
    if(Miller_Rabin(n))
    {
        fac[ct++] = n;
        return ;
    }
    LL p = n;
    LL k = c;
    while(p &gt;= n) p = pollard_rho(p, c--);
    find(p, k);
    find(n / p, k);
}

int main()
{
    LL n;
    while(cin&gt;&gt;n)
    {
        ct = 0;
        find(n, 120);
        sort(fac, fac + ct);
        num[0] = 1;
        int k = 1;
        for(int i=1; i&lt;ct; i++)
        {
            if(fac[i] == fac[i-1])
                ++num[k-1];
            else
            {
                num[k] = 1;
                fac[k++] = fac[i];
            }
        }
        cnt = k;
        for(int i=0; i&lt;cnt; i++)
            cout&lt;&lt;fac[i]&lt;&lt;&quot;^&quot;&lt;&lt;num[i]&lt;&lt;&quot; &quot;;
        cout&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>2.求n1、n2公约数</p>
<p>欧几里得算法（辗转相除法）<br>py代码</p>
<pre><code>def gcd(a, b):
if a &lt; b:
    a, b = b, a
while b != 0:
    temp = a % b
     a = b
     b = temp
def gcd_digui(a, b):
    if b != 0:
           return a
    return gcd(b,a%b)

p = gcd(n1,n2)
</code></pre><p>3.求d：</p>
<p>c++代码：</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    if(b == 0) {
    x = 1; y = 0;
    return a;
}
    LL r = exgcd(b, a % b, x, y);
    LL t = y;
    y = x - a / b * y;
    x = t;
    return r;
}

/*可以得到x&gt;=bound时的x和y，返回true表示有解*/
bool solve(LL a, LL b, LL c, LL bound, LL &amp;x, LL &amp;y) {
    LL xx, yy, d = exgcd(a, b, xx, yy);
    if(c % d) return false;

    xx = xx * c / d; yy = yy * c / d;
    LL t = (bound - xx) * d / b;

    x = xx + b / d * t;
    if(x &lt; bound) {
        t++;
        x = xx + b / d * t;
        }
        y = yy - a / d * t;
        return true;
    }

int main(){
    LL k , e ;
    LL x, y;
    cin&gt;&gt;e&gt;&gt;k;
    solve(e, k, 1, 0, x, y);
    printf(&quot;%lld\n&quot;, x);
    return 0;
}
</code></pre><p>5.加解密</p>
<p>c++代码：</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

LL pow_LL(LL x, LL n, LL mod){
   LL ret = 1;
   while(n &gt; 0){
    if(n &amp; 1) ret = ret * x % mod;
    x = x * x % mod;
    n &gt;&gt;= 1;
   }
    return ret;
}

int main(){
    LL de , n ,i = 0;
    LL arr[100]={0};
    cin&gt;&gt;de&gt;&gt;n;
    for(while(scanf(&quot;%LL&quot;, &amp;arr[i]))) i++;
    for(int i = 0;arr[i];i ++){
        printf(&quot;%c&quot;, pow_LL(arr[i], d, n));
    }
    return 0;
}
</code></pre><p>###常用方法：</p>
<p>1.暴力计算<br> 对于LL内的n，暴力计算，p和q存在相差过大或者过近时用yafu</p>
<p>2.利用公约数<br>有多个极大的n，考虑求gcd</p>
<p>3.小指数攻击<br>e较小时，可能有n &gt; pow(m, e)，所以c = pow(m,e, N) = pow(m, e)，故对密文三次开方，即可得到明文。<br>或者pow(m, e) &gt; n，但是不是足够，假设存在这样的k，有下列的公式成立：<br>c = pow(m, e) + k <em> n<br>爆破k，当且仅当c ­ (k </em> n)可以开三次方，c ­ (k * n)开三次方结果就是明文m。</p>
<p>4.共模攻击<br>假如采用两个或者两个以上的公钥(N,e)来加密同一条信息，求e1<em>s1+e2</em>s2 = 1 ，可以用c1^s1*c2^s2 = m来求名文  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/22/RSA总结/" data-id="cjus78zpk0004gcuzcd8yg0iq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/22/RSA暴力破解/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/04/22/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/22/makerctf-temp-wp/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/22/RSA例题/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/22/RSA共模攻击/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/22/RSA小指数攻击/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/22/RSA暴力破解/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>